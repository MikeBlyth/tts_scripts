-- UTILITIES AND DEBUGGING
bbcodes = bbcodes or {Red='[FF0000]', White='[FFFFFF]', Blue='[0000FF]', Green='[00FF00]',  -- for formatting output to notebook
            Black='[000000]', Grey='[808080]', Yellow='[FFFF00]', None='[-]'}


function dump(o) -- modified
    if o == nil then return 'nil' end
    if type(o) == 'table' then
      local s = '{ '
      if tableIsArray(o) then
        for _, v in ipairs(o) do
          s = s .. dump(v) .. ', '
        end
      else
        for k,v in pairs(o) do
          if type(k) ~= 'number' then k = '"'..k..'"' end
          s = s .. '['..k..']=' .. dump(v) .. ', '
        end
      end
      return s .. '} '
    else
      return tostring(o)
    end
end

function pdump(o, s)
    s = s or ''
    print(s .. ': ' .. dump(o))
end

function tableIsArray(t) -- quick check, see if indices are sequential
  local i = 1
  for k, _ in pairs(t) do
    if k ~= i then return false end
    i = i + 1
  end
  return true
end

function firstWord(s)
    return string.match(s, ('%a+'))
end

function arrayContains(array, value)  -- check if array contains value -- DOESN'T WORK WITH ASSOCIATIVE TABLES!
    for i, v in ipairs(array) do
        if v == value then return i end
    end
    return nil
end

function copyTable(t) --
--- just enough to suit my needs, not a general utility!
  if t == nil then return nil end
  if not type(t) == 'table' then return end
  local new = {}
  for k, v in pairs(t) do
    v2 = v
    if type(v) == 'table' then
        v2 = copyTable(v)
    end
    new[k] = v2
  end
  return new
end

function mergeTables(params, newParams)
-- update params with newParams, return new table
    local t = copyTable(params) or {}
    if newParams then
        for k, v in pairs(newParams) do
            t[k] = v
        end
    end
    return t
end

function arrayRemove(array, value)  --  DOESN'T WORK WITH ASSOCIATIVE TABLES! (Just use array.value = nil)
    local newArray = {}
    for i, v in ipairs(array) do
        if v ~= value then
            table.insert(newArray,v)
        end
    end
    return newArray
end

function printGUIDPosition(guid, msg)
    local pos = getObjectFromGUID(guid).getPosition()
    print(dump(pos))
    printPosition(pos, msg)
end

function printPosition(pos, msg)
  if type(pos) == 'string' then print('Error: first argument to printPosition must be the position vector') end
  assert(pos[1] and pos[2], 'Nil in printPosition' .. dump(pos))
  local str = (msg or '') .. '{' ..
      string.format('%.2f',pos[1] or 'nil') .. ', ' ..
      string.format('%.2f',pos[2] or 'nil')
  if pos[3] then str = str .. ', ' .. string.format('%.2f',pos[3] or 'nil') end
  print(str .. '}')
end
positionPrint = printPosition

function debugPrint(switch, table)
    assert(type(table) == 'table', "Debug print takes switch and table!")
--    print ('debug print, sw=', switch, ': ', debug.switch)
    if debug[switch] then
        for i,v in ipairs(table) do
            print(v)
        end
    end
end

function printDelim(vals, delim )
    local delim = delim or ', '
    s = ''
    for i, v in ipairs(vals) do
        if i ~= 1 then s = s .. delim end
        s = s .. tostring(v)
    end
    print(s)
end

function printNote(s, color)
    defaultNotebookTextColor = 'White'
    notesBuffer = notesBuffer or ''
    if (options ~= nil) and (not options.showNotes) then return end
        -- (options~=nil) so we can use printNote before options has been defined in onLoad()
    local color = color or defaultNotebookTextColor
    bbcolor = bbcodes[color] or ''
    notesBuffer = bbcolor .. s .. bbcodes['None'] .. '\n' .. notesBuffer
    Notes.setNotes(notesBuffer)
end
printNotes = printNote

function clearNotes()
    notesBuffer = ''
    Notes.setNotes('')
end

function printMessage(player, msg, params)
    playerMessageButton(player, msg, params)
end
printMsg = printMessage

----------======== VECTORS ========-------------

function rotate(v, angle)  -- 2d rotation of standard TTS position vector
    local rad = angle * deg2rad
    local sin = math.sin(rad)
    local cos = math.cos(rad)
    local x2 = (cos * v.x) - (sin * v.z)
    local z2 = (sin * v.x) + (cos * v.z)
    return Vector(x2, v.y, z2)
end

-- ======== Formatting =====================
function fmt2(f)
  return string.format("%.2f", f)
end

------============ MAKE PRINTABLE ===========
function makePrintable(t, newToString)
-- Make a table object printable with 'print(t)' using aux function tostring.
-- Ways to call:
--   - makePrintable(t) -- uses an already-existing t.tostring(t) or dump(t)
--     e.g. t={1,2,3};
--			function t.tostring(x) return x[1] .. ':' .. x[2] .. ':' .. x[3] end
--			makePrintable(t)
--   - makePrintable(t, newToString) -- uses new fx (in any namespace)
--   - e.g. makePrintable(t, myArrayDump)
  local mt = getmetatable(t)
  if mt==nil then
    mt = {}
    setmetatable(t,mt)
  end
  if newToString then
    t.tostring = newToString
  end
  --assert(t.tostring, "printtable requires tostring object.tostring function")
  if t.tostring == nil then t.tostring = dump end
  mt.__tostring = t.tostring
end
